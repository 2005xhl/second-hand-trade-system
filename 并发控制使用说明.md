# 数据库并发控制使用说明

## 一、概述

本系统实现了完整的数据库并发控制机制，防止以下并发问题：

1. **脏读（Dirty Read）**：读取到未提交的数据
2. **丢失修改（Lost Update）**：多个事务同时修改同一数据，后提交的覆盖先提交的
3. **不可重复读（Non-Repeatable Read）**：同一事务内多次读取同一数据，结果不一致
4. **幻读（Phantom Read）**：同一事务内多次查询，结果集不一致

## 二、并发控制机制

### 1. 事务隔离级别

系统默认使用 **REPEATABLE READ**（可重复读）隔离级别，这是 MySQL InnoDB 的默认级别，能够：
- ✅ 防止脏读
- ✅ 防止不可重复读
- ✅ 防止大部分幻读（通过间隙锁）

### 2. 悲观锁（Pessimistic Lock）

使用 `SELECT ... FOR UPDATE` 实现行级锁，适用于：
- 关键业务操作（下单、库存扣减）
- 需要强一致性保证的场景

**特点**：
- 锁定期间，其他事务无法修改该行
- 可能导致锁等待，需要设置合理的超时时间
- 适合高并发下的关键操作

### 3. 乐观锁（Optimistic Lock）

使用版本号（version）字段实现，适用于：
- 非关键操作（更新昵称、描述）
- 冲突概率较低的场景

**特点**：
- 不阻塞其他事务读取
- 更新时检查版本号，版本不匹配则更新失败
- 适合读多写少的场景

## 三、使用方法

### 1. 基本事务使用

```python
from db_concurrency import ConcurrencyControl

# 在 DBManager 中已初始化
cc = db_manager.concurrency

# 使用事务上下文管理器
with cc.transaction(isolation_level="REPEATABLE READ") as conn:
    cur = conn.cursor()
    cur.execute("UPDATE goods SET stock_quantity = stock_quantity - 1 WHERE goods_id = %s", (goods_id,))
    # 事务会自动提交，异常时自动回滚
```

### 2. 使用行锁（悲观锁）

```python
with cc.transaction() as conn:
    # 锁定商品行，防止其他事务同时修改
    goods = cc.select_for_update(
        conn,
        "goods",
        "goods_id = %s",
        (goods_id,),
        timeout=5  # 锁超时时间（秒）
    )
    
    if not goods:
        raise Exception("商品不存在")
    
    if goods["stock_quantity"] < quantity:
        raise Exception("库存不足")
    
    # 更新库存
    cur = conn.cursor()
    cur.execute(
        "UPDATE goods SET stock_quantity = stock_quantity - %s WHERE goods_id = %s",
        (quantity, goods_id)
    )
```

### 3. 使用乐观锁（版本号）

**前提**：需要先执行 `add_version_fields.sql` 为表添加 `version` 字段

```python
with cc.transaction() as conn:
    success, msg = cc.update_with_version(
        conn,
        "goods",
        "goods_id",
        goods_id,
        {
            "stock_quantity": new_stock,
            "status": "sold"
        },
        version_field="version"
    )
    
    if not success:
        raise Exception(msg)  # 可能是版本号不匹配，数据已被其他事务修改
```

### 4. 重试机制

```python
def update_goods_stock():
    with cc.transaction() as conn:
        goods = cc.select_for_update(conn, "goods", "goods_id = %s", (goods_id,))
        # ... 更新操作
        pass

# 自动重试，处理锁超时
result = cc.retry_on_lock_timeout(
    update_goods_stock,
    max_retries=3,  # 最多重试3次
    delay=0.1        # 初始延迟0.1秒，每次重试延迟递增
)
```

## 四、已改进的方法

以下方法已经集成了并发控制：

### 1. `add_order()` - 创建订单
- ✅ 使用事务和行锁
- ✅ 锁定商品行，检查库存
- ✅ 原子性更新库存和创建订单

### 2. `update_order_status()` - 更新订单状态
- ✅ 使用事务和行锁
- ✅ 锁定订单行，防止并发修改
- ✅ 订单取消时恢复库存

### 3. `audit_goods()` - 审核商品
- ✅ 使用事务和行锁
- ✅ 锁定商品行，防止审核期间被修改

### 4. `update_user_status()` - 更新用户状态
- ✅ 使用事务和行锁
- ✅ 锁定用户行，防止并发修改

### 5. `update_user_nickname()` - 更新用户昵称
- ✅ 使用事务和行锁
- ✅ 锁定用户行，防止并发修改

## 五、数据库迁移

### 添加版本号字段（可选，用于乐观锁）

执行 `add_version_fields.sql` 脚本：

```bash
mysql -u root -p used_goods_platform < add_version_fields.sql
```

或者手动执行：

```sql
ALTER TABLE `goods` ADD COLUMN `version` INT NOT NULL DEFAULT 1 COMMENT '版本号';
ALTER TABLE `order` ADD COLUMN `version` INT NOT NULL DEFAULT 1 COMMENT '版本号';
ALTER TABLE `user` ADD COLUMN `version` INT NOT NULL DEFAULT 1 COMMENT '版本号';
```

## 六、最佳实践

### 1. 选择锁机制

| 场景 | 推荐机制 | 原因 |
|------|---------|------|
| 下单、库存扣减 | 悲观锁（FOR UPDATE） | 强一致性要求，冲突概率高 |
| 更新昵称、描述 | 乐观锁（版本号） | 冲突概率低，性能更好 |
| 审核、状态变更 | 悲观锁（FOR UPDATE） | 需要保证状态一致性 |

### 2. 事务隔离级别选择

| 隔离级别 | 适用场景 |
|---------|---------|
| READ COMMITTED | 读多写少，对一致性要求不高 |
| REPEATABLE READ | **推荐**，MySQL默认，平衡性能和一致性 |
| SERIALIZABLE | 最高一致性要求，性能较差 |

### 3. 锁超时设置

- 默认：5秒
- 关键操作：3-5秒
- 非关键操作：1-3秒

### 4. 重试策略

- 最大重试次数：3次
- 延迟策略：指数退避（0.1s, 0.2s, 0.4s...）
- 只对锁超时错误重试，其他错误直接抛出

## 七、性能考虑

### 1. 锁粒度

- ✅ 使用行锁（FOR UPDATE），而不是表锁
- ✅ 只锁定必要的行，减少锁冲突

### 2. 事务时长

- ✅ 事务内操作尽量快速
- ✅ 避免在事务内进行耗时操作（网络请求、文件IO等）

### 3. 死锁预防

- ✅ 按相同顺序访问多张表
- ✅ 使用合理的索引，减少锁范围
- ✅ 设置锁超时，避免无限等待

## 八、测试建议

### 1. 并发测试

```python
import threading

def concurrent_order(goods_id):
    # 模拟并发下单
    db_manager.add_order(buyer_id=1, goods_id=goods_id, quantity=1)

# 10个线程同时下单同一商品
threads = []
for i in range(10):
    t = threading.Thread(target=concurrent_order, args=(goods_id,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### 2. 验证点

- ✅ 库存不会超卖
- ✅ 订单数量正确
- ✅ 数据一致性保持
- ✅ 无死锁发生

## 九、常见问题

### Q1: 锁超时怎么办？

A: 使用重试机制，或者检查是否有长时间运行的事务阻塞了锁。

### Q2: 乐观锁版本号不匹配怎么办？

A: 重新读取最新数据，重新计算，再次尝试更新。

### Q3: 如何选择悲观锁还是乐观锁？

A: 
- 冲突概率高 → 悲观锁
- 冲突概率低 → 乐观锁
- 关键业务 → 悲观锁
- 非关键业务 → 乐观锁

### Q4: 事务隔离级别如何选择？

A: 推荐使用 **REPEATABLE READ**（默认），除非有特殊需求。

## 十、总结

本系统通过以下机制保证并发安全：

1. ✅ **事务管理**：统一的事务上下文管理器
2. ✅ **行锁机制**：SELECT ... FOR UPDATE 防止并发修改
3. ✅ **乐观锁**：版本号机制防止丢失修改
4. ✅ **重试策略**：自动处理锁超时
5. ✅ **隔离级别**：REPEATABLE READ 防止脏读和不可重复读

所有关键操作都已集成并发控制，可以安全地处理高并发场景。

